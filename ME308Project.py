# -*- coding: utf-8 -*-
"""ME308Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ypMcRF6f64ufSMC2HpxRWXc9-d2a2Wb8

# ME308 PROJECT: AIRPLANE SCHEDULING AND COST MINIMIZATION

Given a set of routes pq on which there exists an average daily traffic Ppq which must be carried by limited numbers of different types of aircraft, find the least cost assignment of aircraft to routes such that a minimum frequency of daily service on each route is satisfied, and such that aircraft movements balance at every station while not exceeding a daily allowable maximum imposed
by airport congestion.

### Declaring all variables
"""

import numpy

#Adjustable parameters
cities = 10  # no of cities being catered

# The load factor is a metric used in the airline industry that measures the percentage of available seating capacity that has been filled with passengers
LF_pq = numpy.zeros((cities, cities))
# estimated average for daily traffic from p to q
P_pq = numpy.zeros((cities, cities))
# an appropriate direct operating cost for an aircraft a on route pq
DC_pq = numpy.zeros((cities, cities))
# Stores distance between 2 airports p and q
d_pq = numpy.zeros((cities, cities))
# stores seating capacity for a given aircraft
S = 180
# estimated average for daily traffic from p to q
P_pq = numpy.zeros((cities, cities))
# block hours for aircraft a to fly route pq
# Block time includes the time to taxi-out to the runway, the actual flight duration and the time to taxi to the arrival gate, but the published schedule for the flight doesn't break these elements apart.
Tb_pq = numpy.zeros((cities, cities))
# assumed average daily utilization for fleet a [in hours] - depends on stage length as well (the amount of time plane has flown)
U = 8
# number of aircrafts
A = 50
# a specified minimum level of service should be maintained on each route
Nmin_pq = numpy.zeros((cities, cities))
# maximum number of daily departures allowed at station p
N_maxp = numpy.zeros(cities)

"""### Initialization of variables

Some information before code
We take three cities for testing - Mumbai, Delhi, Lucknow <br>
Distance(Mumbai->Delhi) = 1137Km <br>
Distance(Delhi->Lucknow) = 553Km <br>
Distance(Mumbai->Lucknow) = 1378km <br>
<br>
Seating capacity of plane is equal to 180 <br><br>
Since Delhi and Lucknow are close to each other people also prefer superfast trains as compared to flight since it takes same time. So load factor for Delhi to Lucknow might be low.<br>
But in our case we assume constant load factor = 1<br>
Average daily traffic from one city to other is taken as 1000 for Mumbai to Delhi, 400 for Delhi to Lucknow and 700 for Mumbai to Lucknow<br><br>
One major assumption is aircrafts fly at same velocity throughout the journey and velocity of aircraft is ~900km/hr <br>
Fuel cost = INR 40 per litre (assuming full seats) # is not valid when LF<1 though <br>
Fuel consumption = 4.18 L/km (Data for A320) <br>
DC = fuel consumption * distance * fuel cost <br>
<br>
Block time = distance/velocity + 1hr<br><br>
Assumed average utilisation is 8hrs
<br><br>
Minimum level of service = 1
<br>
Maximum level of service = 900 for Mumbai, 800 for Delhi and 100 for Lucknow
<br>
No of aircrafts = 1000
"""

# Function to calculate distance given latitudes and longitudes
import numpy as np
def gcd(coord1, coord2):
    c1 = np.deg2rad(coord1) # phi lambda
    c2 = np.deg2rad(coord2)
    
    p1 = c1[0]
    p2 = c2[0]
    dl = c1[1] - c2[1]
    
    a1 = np.cos(p2) * np.sin(dl)
    a2 = np.cos(p1) * np.sin(p2) - np.sin(p1) * np.cos(p2) * np.cos(dl)
    a3 = np.sin(p1) * np.sin(p2) + np.cos(p1) * np.cos(p2) * np.cos(dl)
    dsigma = np.arctan2(np.sqrt(a1**2 + a2**2), a3)
    
    return 6371 * dsigma

stations = ['Mumbai', 'Delhi', 'Lucknow', 'Hyderabad', 'Ahmedabad', 'Banglore', 'Pune', 'Kolkata', 'Chennai', 'Jaipur']
coords = [(19.076090, 72.877426), (28.679079, 77.069710), (26.850000, 80.949997),
         (17.3667, 78.4667), (23.0300, 72.5800), (12.9699, 77.5980),
         (18.5196, 73.8553), (22.5411, 88.3378), (13.0825, 80.2750),
         (26.9167, 75.8667)]
# (22.5411, 88.3378)
nstations = len(stations)
distance = numpy.zeros((nstations, nstations))
for origin in stations:
    s = stations.index(origin)
    for destination in stations:
        e = stations.index(destination)
        distance[s, e] = gcd(coords[s], coords[e])
print(distance)
print(distance.shape)

# Generation of demand matrix
import math
weights = [2, 1.8, 1, 1.5, 1.5, 2, 0.5, 1.8, 2, 1.5] #denotes how busy an airport is
mu, sigma = 500, 0.1
s = np.random.normal(mu, sigma, cities*cities)
s = s.reshape(cities, cities)
demand = numpy.zeros((cities, cities))
for i in range(cities):
  for j in range(cities):
    demand[i][j] = math.floor(weights[i]*weights[j]*s[i][j])
    if i==j:
      demand[i][j] = 0
print(demand)

import numpy as np
# The order is Mumbai, Delhi, Lucknow in each case
LF_pq = np.array(np.ones((cities, cities)))
fuel_cost = 40
fuel_consumption = 4.18
# d_pq = numpy.array([
#     [0, 1137, 1378],
#     [1137, 0, 553],
#     [1378, 553, 0]
# ])
d_pq = np.array(distance)
DC_pq = np.array(np.dot(d_pq, fuel_cost*fuel_consumption))
S = 180
# P_pq = np.array([
#     [0, 1000, 700],
#     [1000, 0, 400],
#     [700, 400, 0]
# ]) # assume symmetric demand as of now
P_pq = np.array(demand)
Tb_pq = d_pq/900+1 #addition of 1 is for gate closing and onboarding time
for i in range(cities):
  Tb_pq[i][i] = 0 #since no flight is between them
U = 12
A = 1000
Nmin_pq = np.array(np.ones((cities, cities)))
for i in range(cities):
  Nmin_pq[i][i] = 0 #no flights to same airport
# Nmax_p = np.array([900, 800, 100])
Nmax_p = [math.floor(np.random.normal(100, 0.1)*weights[i]) for i in range(cities)]
print(Nmax_p)

"""### Initialising pulp and creating decision variable"""

pip install pulp

from pulp import *
# decision variable
n_pq = LpVariable.dicts("n", (range(cities), range(cities)), cat="Integer")
print(n_pq)

"""## Optimization problem
Minimize operating cost for fixed revenue $$\sum_{pq}DC_{pq}n_{pq}$$
The model is of LP minimization type with the following constraints<br>
1. Demand on all routes must be carried (Load factor is 1)
$$\sum S n_{pq} \ge P_{pq} \forall pq$$
2. Fleet availability must not be exceeded
$$\sum_{pq} Tb_{pq}n_{pq} \le UA$$
3. Aircraft movements must balance over the day at every station
$$\sum_{q}n_{pq} = \sum_{q}n_{qp}$$
4. Minimum daily frequency must be maintained on each route
$$\sum n_{pq} \ge Nmin_{pq}$$
5. Maximum daily departures at a station are limited due to airport capacity
$$\sum_{q}n_{pq} \le Nmax_{p}$$
"""

model = LpProblem("Airline Cost Minimizer", LpMinimize)
model += lpSum([DC_pq[i][j] * n_pq[i][j] for i in range(cities) for j in range(cities)]); #optimization function
for i in range(cities):
  for j in range(cities):
    model += S*n_pq[i][j]>=P_pq[i][j];
    # model += S*n_pq[i][j]==P_pq[i][j];
    model += n_pq[i][j] >= Nmin_pq[i][j]
model += lpSum([Tb_pq[i][j] * n_pq[i][j] for i in range(cities) for j in range(cities)]) <= U*A;
for i in range(cities):
  model += lpSum(n_pq[i][j] for j in range(cities)) == lpSum(n_pq[j][i] for j in range(cities))
  model += lpSum(n_pq[i][j] for j in range(cities)) <= Nmax_p[i]
print(model);

"""### Solving the model"""

status = model.solve()

LpStatus[status]

# stations = ['Mumbai', 'Delhi', 'Lucknow', 'Hyderabad', 'Ahmedabad', 'Banglore', 'Pune', 'Kolkata', 'Chennai', 'Jaipur']
num_flights = np.zeros((cities, cities))
dummy = []
for v in model.variables():
    dummy.append(v.varValue)
    print(v.name, "=", v.varValue)
num_flights = np.array(dummy).reshape(cities, cities)
print(num_flights)

total_min_cost = model.objective.value()

"""## Predicting ticket fares"""

base_fare = np.zeros((cities, cities))
for i in range(cities):
  for j in range(cities):
    base_fare[i][j] = DC_pq[i][j]*num_flights[i][j]/P_pq[i][j]
base_fare = np.array(base_fare)
base_fare = base_fare*2 #account for crew salaries and profit
print(base_fare);

"""# Profit of Airline"""

revenue = 0
for i in range(cities):
  for j in range(cities):
    if math.isnan(base_fare[i][j]):
      pass
    else:
      revenue += base_fare[i][j]*P_pq[i][j]
profit = revenue - total_min_cost
print("Profit of Airline is ", profit)

"""## Tabulating the reuslts"""

# Tabulating the results
!pip install tabulate
# !pip install python-docx

# import docx
from tabulate import tabulate
# doc = docx.Document()
# doc.add_heading('AIRLINE XYZ', 0)
# doc.add_heading('No of aircrafts = 100', 3)
# doc.add_heading('Seating capacity of aircraft = 180', 3)
headers = ["Destination", "Distance", "Block Time(in hrs)", "Cost per flight(INR)", "Demand", "# Flights", "Ticket cost"]
def get_all_stat():
  for i in range(cities):
    # doc.add_heading(stations[i], 0)
    table = []
    for j in range(cities):
      table_data = []
      table_data.append(stations[j])
      table_data.append(d_pq[i][j])
      table_data.append(Tb_pq[i][j])
      table_data.append(DC_pq[i][j])
      table_data.append(P_pq[i][j])
      table_data.append(num_flights[i][j])
      table_data.append(base_fare[i][j])
      table.append(table_data)
    # doc.add_heading(tabulate(table, headers, tablefmt="fancy_grid"), 3)
    print(tabulate(table, headers, tablefmt="fancy_grid"))

# doc.save("nikhil.docx")

def get_airport_stat(i):
  table = []
  for j in range(cities):
    table_data = []
    table_data.append(stations[j])
    table_data.append(d_pq[i][j])
    table_data.append(Tb_pq[i][j])
    table_data.append(DC_pq[i][j])
    table_data.append(P_pq[i][j])
    table_data.append(num_flights[i][j])
    table_data.append(base_fare[i][j])
    table.append(table_data)
  print(tabulate(table, headers, tablefmt="fancy_grid"))

get_airport_stat(2)

"""## Demand Generation"""

# Discretising every 10 minutes for 24hrs
step = int(24*60/10)
print(step)
mu, sigma = 1000, 0.5
pairwise_demand_timewise = np.zeros((cities, cities, step))
for i in range(cities):
  for j in range(cities):
    sum = 0
    for k in range(step):
      if P_pq[i][j] == 0:
        pass;
      else:
        num = np.random.normal(mu, sigma)
        sum += num
        pairwise_demand_timewise[i][j][k] = num
    if sum == 0:
      pass
    else:
      pairwise_demand_timewise[i][j] *= P_pq[i][j]/sum
sum_new = 0
for k in range(144):
  sum_new += pairwise_demand_timewise[0][1][k]
print(sum_new)

"""# TIME CONSIDERATION

## Generating relevant data and files
"""

import numpy as np
import pickle
import matplotlib.pyplot as plt

opmin = 18 * 60
dt = 60 # minutes
ndt = opmin // dt # number of time steps
dt, ndt

def get_demand(npax):
  mu = npax / opmin
  demand = np.random.normal(mu, 0.1, ndt)
  k = np.uint32(demand)
  return k

def people_on_airport(demand):
  people_on_airport = [0]
  for d in demand:
      people_on_airport.append(people_on_airport[-1] + d * dt)

  people_on_airport = people_on_airport[1:]
  plt.figure()
  plt.grid()
  plt.plot(np.arange(ndt) * dt, people_on_airport)
  plt.title("Demand vs time")
  plt.show()

def get_mdemand(k):
  mdemand = {}
  for i in range(ndt):
      mdemand[i * dt] = k[i]
  return mdemand

"""# Generating schedule"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import pickle

from typing import List, Tuple
from numpy.typing import NDArray

"""
Computes the edge wait for the edge connecting (y, t) to (y + demand[t]*dt, t+dt)
"""
def wait_penalty(y: int, t: int, demand: NDArray[np.uint32], K: int, dt: int) -> float:
    return K * (y + demand[t] * dt)

def create_edge(edge_list: List[Tuple], y: int, t: int, demand: NDArray[np.uint32], penalty_coeff: float, dispatch_cost: float, seats: int, dt: int, ndt: int) -> None:
    if (t == dt * ndt) and (y - seats < 0):
        return
    
    if not t >= dt * ndt:
        # print((
        #     (y, t),
        #     (y + demand[t]*dt, t + dt),
        #     wait_penalty(y, t, demand, penalty_coeff, dt)
        # ))
        edge_list.append((
            (y, t),
            (y + demand[t]*dt, t + dt),
            wait_penalty(y, t, demand, penalty_coeff, dt)
        ))
        create_edge(edge_list, y + demand[t]*dt, t + dt, demand, penalty_coeff, dispatch_cost, seats, dt, ndt)

    if y - seats >= 0:
        # print((
        #     (y, t),
        #     (y - seats, t),
        #     dispatch_cost
        # ))
        edge_list.append((
            (y, t),
            (y - seats, t),
            dispatch_cost
        ))

        create_edge(edge_list, y - seats, t, demand, penalty_coeff, dispatch_cost, seats, dt, ndt)
    else:
        # print((
        #     (y, t),
        #     (0, t),
        #     dispatch_cost
        # ))
        edge_list.append((
            (y, t),
            (0, t),
            dispatch_cost
        ))
        
        if not t == dt * ndt:
            create_edge(edge_list, 0, t + dt, demand, penalty_coeff, dispatch_cost, seats, dt, ndt)

def init(i,j):
  source = i
  destination = j
  k = get_demand(P_pq[i][j])
  people_on_airport(k)
  mdem = get_mdemand(k)
  penalty_coeff = DC_pq[i][j]/(S+20)
  seats = S
  dispatch_cost = DC_pq[i][j]
  wel = []
  create_edge(wel, 0, 0, mdem, penalty_coeff, dispatch_cost, seats, dt, ndt-1)
  s = set(wel)
  s_new = set({})
  for i in s:
    if i[0][0]==0 and i[1][0]==0 and i[0][1]==i[1][1]:
      pass
    else:
      s_new.add(i)
  wel = list(s_new)
  DG = nx.DiGraph()
  DG.add_weighted_edges_from(wel)
  path = nx.dijkstra_path(DG, (0, 0), (0, 1020))
  path_edges = list(zip(path,path[1:]))
  pos = nx.spring_layout(DG)
  plt.figure(3,figsize=(12,12))
  plt.title("Space Time graph for airport pair "+stations[source]+" and "+stations[destination])
  nx.draw_networkx_nodes(DG,pos,nodelist=set(DG.nodes)-set(path),node_size=20, node_color='b')
  nx.draw_networkx_edges(DG, pos, edgelist=set(DG.edges)-set(path_edges), edge_color='b', connectionstyle='arc3, rad = 0.9')
  nx.draw_networkx_nodes(DG, pos, nodelist=path ,node_size=30, node_color='r')
  nx.draw_networkx_edges(DG,pos,edgelist=path_edges,edge_color='r', connectionstyle='arc3, rad = 0.9')
  plt.show()
  departure_time = []
  arrival_time = []
  flight_names = []
  iter = 0
  for l in path:
    if l[0]==0 and l[1]==0:
      pass
    else:
      if l[0]==0:
        iter = iter+1
        departure_time.append((6+(l[1]/60))%24) #stores in 24 hr format, airport starts at 6AM and closes at 12AM
        arrival_time.append((6+(l[1]/60)+(math.floor(Tb_pq[source][destination])+(Tb_pq[source][destination]%1)*0.6))%24)
        flight_names.append("KF"+str(source)+str(destination)+str(iter))
      else:
        pass
  table = []
  for i in range(len(departure_time)):
    table_data = []
    table_data.append(flight_names[i])
    table_data.append(departure_time[i])
    table_data.append('%.2f' %arrival_time[i])
    table.append(table_data)
  headers = ["Flight Number", "Scheduled Departure (in 24hrs format)", "Scheduled Arrival (in 24hrs format)"]
  print("Flight Schedule for the day")
  print(tabulate(table, headers, tablefmt="fancy_grid"))

init(0,1)

"""# Visualizing the results"""

!pip install ipywidgets

import ipywidgets as widgets
dropdown_src = widgets.Dropdown(options = stations)
dropdown_dst = widgets.Dropdown(options = stations)
airports = ["All"]
for i in range(len(stations)):
  airports.append(stations[i])
dropdown_station = widgets.Dropdown(options = airports)
src=0
dst=0
def src_station_handler(change):
  for i in range(len(stations)):
    if stations[i] == change.new:
      src = i
  init(src, dst)
def dst_station_handler(change):
  for i in range(len(stations)):
    if stations[i] == change.new:
      dst = i
  init(src, dst)
def station_handler(change):
  if change.new == "All":
    get_all_stat()
  else:
    for i in range(len(stations)):
      if stations[i] == change.new:
        src = i
    get_airport_stat(i)
dropdown_src.observe(src_station_handler, names='value')
dropdown_dst.observe(dst_station_handler, names='value')
dropdown_station.observe(station_handler, names="value")
print("\n----------------------------------------------------------------------------------------------------------")
print("AIRPORT WISE AIRLINE STATISTICS")
print("----------------------------------------------------------------------------------------------------------")
print("Choose an airport")
display(dropdown_station)
print("\n----------------------------------------------------------------------------------------------------------")
print("FLIGHT SCHEDULING FOR PAIR OF AIRPORTS")
print("----------------------------------------------------------------------------------------------------------")
print("Choose source airport")
display(dropdown_src)
print("Choose. destination airport")
display(dropdown_dst)
print("\n----------------------------------------------------------------------------------------------------------")
print("OUTPUT")
print("----------------------------------------------------------------------------------------------------------\n")

